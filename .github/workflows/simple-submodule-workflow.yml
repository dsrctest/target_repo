name: Simple Submodule Workflow

on:
  pull_request:
    types: [opened, closed]
    branches: [main]
  workflow_dispatch:
    inputs:
      folder_name:
        description: 'Folder name to convert to submodule'
        required: true
        type: string
      new_repo:
        description: 'New repository name (owner/repo-name)'
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write
  actions: read

jobs:
  convert-to-submodule:
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.ORG_ADMIN_TOKEN || secrets.GITHUB_TOKEN }}
        submodules: false  # Don't initialize submodules to avoid conflicts

    - name: Extract metadata
      id: meta
      run: |
        echo "üîç Extracting metadata..."
        echo "Event: ${{ github.event_name }}"
        
        # Check if this is a manual trigger or PR merge
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # Manual trigger - use inputs
          FOLDER_NAME="${{ inputs.folder_name }}"
          NEW_REPO="${{ inputs.new_repo }}"
          ORG_NAME=$(echo "$NEW_REPO" | cut -d'/' -f1)
          echo "üìù Manual trigger: $FOLDER_NAME -> $NEW_REPO"
        else
          # PR merge - extract from PR body
          echo "üìù Extracting from PR body..."
          BODY=$(jq -r '.pull_request.body // "N/A"' "$GITHUB_EVENT_PATH")
          echo "PR Body preview: $(echo "$BODY" | head -c 200)..."
          
          # Extract folder name - look for "Add folder: " pattern first
          FOLDER_NAME=$(echo "$BODY" | grep -oE 'Add folder: ([^(]+)' | sed 's/Add folder: //' | head -1)
          
          # If not found, try submodule metadata
          if [ -z "$FOLDER_NAME" ]; then
            FOLDER_NAME=$(echo "$BODY" | grep -oE 'submodule_name: ([^\\n]+)' | sed 's/submodule_name: //' | tr -d ' ')
          fi
          
          # If still not found, try old format
          if [ -z "$FOLDER_NAME" ]; then
            FOLDER_NAME=$(echo "$BODY" | grep -oE 'Submodule-Name:[ ]*([^[:space:]\\n]+)' | sed 's/Submodule-Name:[ ]*//')
          fi
          
          # Clean the folder name (remove leading/trailing spaces and dashes)
          FOLDER_NAME=$(echo "$FOLDER_NAME" | sed -e 's/^[[:space:]-]*//' -e 's/[[:space:]-]*$//')
          
          # Extract org name
          ORG_NAME=$(echo "$BODY" | grep -oE 'submodule_org: ([^\\n]+)' | sed 's/submodule_org: //' | tr -d ' ')
          if [ -z "$ORG_NAME" ]; then
            ORG_NAME=$(echo "$BODY" | grep -oE 'Submodule-Org:[ ]*([^[:space:]\\n]+)' | sed 's/Submodule-Org:[ ]*//')
          fi
          
          # Default values if not found
          if [ -z "$FOLDER_NAME" ]; then
            echo "‚ö†Ô∏è  Could not extract folder name from PR body"
            # Try to get from commit messages
            FOLDER_NAME_LIST=$(git log --oneline -10 | grep -oE 'Add folder: ([^(]+)' | sed 's/Add folder: //' | head -1)
            if [ -n "$FOLDER_NAME_LIST" ]; then
              FOLDER_NAME="$FOLDER_NAME_LIST"
              echo "üìù Found folder name from commit: $FOLDER_NAME"
            else
              echo "‚ùå No folder name found, using fallback"
              exit 1
            fi
          fi
          
          if [ -z "$ORG_NAME" ]; then
            ORG_NAME="dsrctest"
          fi
          
          NEW_REPO="$ORG_NAME/$FOLDER_NAME"
          
          echo "üì¶ Extracted metadata:"
          echo "  Folder: $FOLDER_NAME"
          echo "  Org: $ORG_NAME"
          echo "  Repo: $NEW_REPO"
        fi
        
        echo "folder_name=$FOLDER_NAME" >> $GITHUB_OUTPUT
        echo "org_name=$ORG_NAME" >> $GITHUB_OUTPUT
        echo "new_repo=$NEW_REPO" >> $GITHUB_OUTPUT
        # Create a sanitized branch name from folder (e.g., submodule/folder-name)
        BRANCH_NAME=$(echo "submodule/$FOLDER_NAME" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._\/-]+/-/g; s/-+/-/g; s#/+#/#g; s#(^/|/$)##g; s/-$//')
        echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

    - name: Clean up broken submodules
      run: |
        echo "üßπ Cleaning up any broken submodules..."
        
        # Check if .gitmodules exists and fix any broken entries
        if [ -f .gitmodules ]; then
          echo "üìã Checking .gitmodules file..."
          cat .gitmodules
          
          # Fix any submodules with missing URLs (comment them out)
          sed -i 's/\[submodule "deepcraft44"\]/\[submodule "deepcraft44"-disabled\]/' .gitmodules || true
          
          echo "‚úÖ Cleaned up broken submodule references"
        fi

    - name: Verify folder exists
      run: |
        FOLDER="${{ steps.meta.outputs.folder_name }}"
        FOLDER=$(printf '%s' "$FOLDER" | sed -e 's/^[[:space:]]\+//' -e 's/[[:space:]]\+$//')
        echo "üîç Checking if folder '$FOLDER' exists..."
        echo "üìä Folder name length: ${#FOLDER}"
        echo "üìä Folder name bytes: $(echo -n "$FOLDER" | xxd)"
        
        # Check if folder exists as directory or submodule
        if [ -d "$FOLDER" ]; then
          echo "‚úÖ Found folder: $FOLDER"
          ls -la "$FOLDER"
        elif [ -f "$FOLDER" ]; then
          echo "‚ö†Ô∏è  Found file (not directory): $FOLDER"
          ls -la "$FOLDER"
        else
          echo "‚ùå Folder '$FOLDER' not found"
          echo "üìÅ Available directories:"
          ls -la
          echo "üìÇ Contents of root:"
          find . -maxdepth 2 -type d | head -20
          
          # Try to find similar folder names
          echo "üîç Looking for similar folder names..."
          find . -maxdepth 1 -type d -name "*$(echo "$FOLDER" | cut -c1-5)*" 2>/dev/null || echo "No similar folders found"
          
          exit 1
        fi
        
        echo "‚úÖ Folder '$FOLDER' exists"
        echo "üìä Folder contents:"
        ls -la "$FOLDER"
        echo "üìä File count: $(find "$FOLDER" -type f | wc -l)"

    - name: Configure Git
      run: |
        git config user.name "${{ github.actor }}"
        git config user.email "${{ github.actor }}@users.noreply.github.com"
        echo "Git user configured: ${{ github.actor }}"
        
    - name: Setup GitHub CLI
      env:
        GH_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN || secrets.GITHUB_TOKEN }}
      run: |
        # Setup GitHub CLI authentication
        gh auth setup-git
        echo "GitHub CLI authenticated"
        
        # Verify authentication
        gh auth status
        echo "‚úÖ GitHub CLI ready"

    - name: "Step 1: Create new repository in organization"
      env:
        GH_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN || secrets.GITHUB_TOKEN }}
      run: |
        NEW_REPO="${{ steps.meta.outputs.new_repo }}"
        FOLDER="${{ steps.meta.outputs.folder_name }}"
        
        echo "üèóÔ∏è STEP 1: Creating new repository '$NEW_REPO' in organization"
        echo "üìã Repository will be created as: $NEW_REPO"
        
        # Check if repository already exists
        if gh repo view "$NEW_REPO" >/dev/null 2>&1; then
          echo "‚ö†Ô∏è  Repository $NEW_REPO already exists - will skip creation"
        else
          echo "üî® Creating new organization repository: $NEW_REPO"
          
          # Create repository in organization (correct syntax for modern GitHub CLI)
          DESCRIPTION="Source repository for '$FOLDER' submodule (auto-generated from PR #${{ github.event.pull_request.number }})"
          
          echo "Creating repository with description: $DESCRIPTION"
          
          if gh repo create "$NEW_REPO" \
            --private \
            --description "$DESCRIPTION" \
            --confirm; then
            
            echo "‚úÖ Successfully created repository: $NEW_REPO"
            
            # Wait for GitHub to properly initialize the repository
            echo "‚è≥ Waiting for repository initialization..."
            sleep 15
            
            # Verify repository was created successfully
            if gh repo view "$NEW_REPO" >/dev/null 2>&1; then
              echo "‚úÖ Repository $NEW_REPO fully initialized and ready"
              echo "üîó Repository URL: https://github.com/$NEW_REPO"
            else
              echo "‚ùå Failed to verify repository creation"
              echo "üîç Attempting repository view for debugging..."
              gh repo view "$NEW_REPO" || echo "Repository not accessible"
              exit 1
            fi
          else
            echo "‚ùå Failed to create repository: $NEW_REPO"
            echo "üîç Debug: Checking organization access..."
            gh auth status
            exit 1
          fi
        fi

    - name: "Step 2: Push local files to new repository (on branch)"
      env:
        GH_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN || secrets.GITHUB_TOKEN }}
      run: |
        FOLDER="${{ steps.meta.outputs.folder_name }}"
        NEW_REPO="${{ steps.meta.outputs.new_repo }}"
        BRANCH_NAME="${{ steps.meta.outputs.branch_name }}"
        
        echo "üìÇ STEP 2: Pushing all files from local folder '$FOLDER' to new repository '$NEW_REPO' on branch '$BRANCH_NAME'"
        echo "üìÅ Source folder: $FOLDER"
        echo "üèóÔ∏è Target repository: $NEW_REPO"
        
        # Create temporary directory
        TMPDIR=$(mktemp -d)
        echo "üìÅ Using temporary directory: $TMPDIR"
        
        cd "$TMPDIR"
        
        # Clone the new repository
        echo "üîÑ Cloning repository: $NEW_REPO"
        gh repo clone "$NEW_REPO" repo || {
          echo "‚ùå Failed to clone repository"
          exit 1
        }
        
        cd repo
        echo "‚úÖ Successfully cloned repository"
        # Ensure branch exists locally
        git fetch origin || true
        if git rev-parse --verify "$BRANCH_NAME" >/dev/null 2>&1; then
          git checkout "$BRANCH_NAME"
        else
          git checkout -b "$BRANCH_NAME"
        fi
        
        # Copy folder content
        echo "üìÑ Copying folder contents..."
        if [ -d "$GITHUB_WORKSPACE/$FOLDER" ] && [ "$(ls -A "$GITHUB_WORKSPACE/$FOLDER" 2>/dev/null)" ]; then
          echo "üìã Copying files from $FOLDER"
          cp -r "$GITHUB_WORKSPACE/$FOLDER"/. .
          
          # Show what was copied
          echo "üìä Copied files:"
          find . -type f | head -20
          echo "üìà Total files: $(find . -type f | wc -l)"
        else
          echo "‚ö†Ô∏è  Folder is empty, creating README"
          
          echo "# $FOLDER" > README.md
          echo "" >> README.md
          echo "This is the source repository for the $FOLDER submodule." >> README.md
          echo "" >> README.md
          echo "## Contents" >> README.md
          echo "This repository contains the source code for the $FOLDER component that is included as a submodule in the main project." >> README.md
          echo "" >> README.md
          echo "## Usage" >> README.md
          echo "This submodule is automatically managed by the main repository's workflow system." >> README.md
          echo "" >> README.md
          echo "*Generated automatically by GitHub Actions on $(date)*" >> README.md
        fi
        
        # Configure git identity (both global and local) to avoid empty ident errors
        git config --global user.name "${{ github.actor }}"
        git config --global user.email "${{ github.actor }}@users.noreply.github.com"
        git config user.name "${{ github.actor }}"
        git config user.email "${{ github.actor }}@users.noreply.github.com"
        export GIT_AUTHOR_NAME="${{ github.actor }}"
        export GIT_AUTHOR_EMAIL="${{ github.actor }}@users.noreply.github.com"
        export GIT_COMMITTER_NAME="${{ github.actor }}"
        export GIT_COMMITTER_EMAIL="${{ github.actor }}@users.noreply.github.com"
        
        # Add and commit
        git add .
        if git diff --staged --quiet; then
          echo "‚ö†Ô∏è  No changes to commit"
        else
          git commit -m "Initial commit: Add $FOLDER source content - Auto-generated from main repository PR #${{ github.event.pull_request.number || 'manual' }}"
          echo "‚úÖ Changes committed"
        fi
        
        # Push using GitHub CLI (to branch)
        gh auth setup-git
        git push -u origin "$BRANCH_NAME"
        
        echo "‚úÖ Successfully pushed content to $NEW_REPO (branch $BRANCH_NAME)"

    - name: "Step 3: Convert original folder to submodule (tracking branch)"
      env:
        GH_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN || secrets.GITHUB_TOKEN }}
      run: |
        FOLDER="${{ steps.meta.outputs.folder_name }}"
        NEW_REPO="${{ steps.meta.outputs.new_repo }}"
        BRANCH_NAME="${{ steps.meta.outputs.branch_name }}"
        REPO_URL="https://${{ secrets.ORG_ADMIN_TOKEN || secrets.GITHUB_TOKEN }}@github.com/$NEW_REPO.git"
        
        echo "üîó STEP 3: Converting original folder '$FOLDER' to submodule"
        echo "üìÇ Original folder: $FOLDER"
        echo "üèóÔ∏è New submodule source: $NEW_REPO"
        echo "üîó Submodule URL: $REPO_URL"
        
        # Setup authentication
        gh auth setup-git
        
        # Remove existing folder and any broken submodules
        echo "üóëÔ∏è Removing existing folder and cleaning submodules..."
        
        # Clean up broken submodules first
        if [ -f .gitmodules ]; then
          echo "üßπ Fixing broken submodules in .gitmodules..."
          
          # Create a clean .gitmodules file without broken entries
          grep -v "deepcraft44" .gitmodules > .gitmodules.clean || cp .gitmodules .gitmodules.clean
          mv .gitmodules.clean .gitmodules
          
          echo "‚úÖ Cleaned broken submodule entries"
        fi
        
        # Remove the target folder (both as regular folder and possibly as broken submodule)
        git rm -rf "$FOLDER" || {
          echo "‚ö†Ô∏è  Could not remove folder with git (may not exist), trying direct removal..."
          rm -rf "$FOLDER" || echo "Folder not found or already removed"
        }
        
        # Add as submodule (use clean URL without token)
        echo "‚ûï Adding submodule tracking branch '$BRANCH_NAME'..."
        CLEAN_REPO_URL="https://github.com/$NEW_REPO.git"
        
        # Configure git to use token for submodule operations
        git config url."https://${{ secrets.ORG_ADMIN_TOKEN || github.token }}@github.com/".insteadOf "https://github.com/"
        
        git submodule add -b "$BRANCH_NAME" "$CLEAN_REPO_URL" "$FOLDER" || {
          echo "‚ùå Failed to add submodule"
          git status
          exit 1
        }
        
        # Reset git config to avoid token in .gitmodules
        git config --unset url."https://${{ secrets.ORG_ADMIN_TOKEN || github.token }}@github.com/".insteadOf
        
        echo "‚úÖ Submodule added successfully"
        
        # Commit submodule addition
        echo "üíæ Committing submodule addition..."
        git add .gitmodules "$FOLDER"
        
        if git diff --staged --quiet; then
          echo "‚ö†Ô∏è  No staged changes to commit"
        else
          git commit -m "Convert $FOLDER to submodule from $NEW_REPO - Automatically converted from folder to submodule after PR merge. Submodule source: https://github.com/$NEW_REPO"
          echo "‚úÖ Submodule conversion committed"
        fi

    - name: "Step 4: Merge submodule changes to main branch"
      env:
        GH_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN || secrets.GITHUB_TOKEN }}
      run: |
        echo "üöÄ STEP 4: Merging submodule changes to main branch"
        
        # Ensure authentication
        gh auth setup-git
        
        # Show status before merge
        echo "üìã Git status before merge:"
        git status
        
        # Pull latest changes to avoid conflicts
        echo "üîÑ Pulling latest changes from remote..."
        git pull origin main --no-edit || {
          echo "‚ö†Ô∏è  Pull failed, but continuing..."
        }
        
        # Create a merge commit for the submodule conversion
        echo "üîÄ Creating merge commit for submodule conversion..."
        MERGE_MSG="Merge: Convert ${{ steps.meta.outputs.folder_name }} to submodule - Created organization repository: ${{ steps.meta.outputs.new_repo }} - Converted folder to submodule tracking branch: ${{ steps.meta.outputs.branch_name }} - Submodule source: https://github.com/${{ steps.meta.outputs.new_repo }} - Auto-generated from PR #${{ github.event.pull_request.number || 'manual' }}"
        
        # Commit the merge
        git commit --no-edit -m "$MERGE_MSG" || {
          echo "‚ö†Ô∏è  No merge commit needed (already up to date)"
        }
        
        # Push the merged changes to main
        echo "üöÄ Pushing merged changes to main branch..."
        git push origin main || {
          echo "‚ùå Standard push failed, trying force push..."
          git push --force-with-lease origin main || {
            echo "‚ùå Force push also failed, showing git configuration:"
            git config --list | grep -E "(user|remote)"
            git remote -v
            git log --oneline -5
            exit 1
          }
        }
        
        echo "‚úÖ Successfully merged submodule changes to main branch"
        echo "üéâ Submodule conversion completed for '${{ steps.meta.outputs.folder_name }}'"
        echo "üîó Submodule: https://github.com/${{ steps.meta.outputs.new_repo }}"
        echo "üìÑ Main branch updated with submodule reference"

    - name: Handle workflow failure
      if: failure()
      run: |
        echo "‚ùå Workflow failed - investigating..."
        
        echo "üìã Current git status:"
        git status || echo "Git status failed"
        
        echo "üìÅ Current directory contents:"
        ls -la || echo "Directory listing failed"
        
        echo "üîó Git configuration:"
        git config --list | grep -E "(user|remote)" || echo "Git config failed"
        
        echo "üíæ Submodules status:"
        git submodule status || echo "Submodule status failed"
        
        echo "üìÑ .gitmodules content:"
        cat .gitmodules 2>/dev/null || echo "No .gitmodules file"
        
        echo "‚ö†Ô∏è  Workflow will continue despite this error..."
