name: PR Submodule Workflow
on:
  pull_request:
    types: [opened, closed]

permissions:
  contents: write
  pull-requests: write
  repository-projects: write

jobs:
  # Job 1: When PR is opened - just comment (no action needed)
  pr-opened:
    if: github.event.action == 'opened'
    runs-on: ubuntu-latest
    steps:
      - name: Extract metadata from PR body
        id: meta
        run: |
          BODY=$(jq -r '.pull_request.body' "$GITHUB_EVENT_PATH")
          NAME=$(echo "$BODY" | sed -n 's/^Submodule-Name:[[:space:]]*//p' | head -1)
          ORG=$(echo "$BODY"  | sed -n 's/^Submodule-Org:[[:space:]]*//p'   | head -1)
          if [ -z "$NAME" ] || [ -z "$ORG" ]; then
            echo "Missing Submodule-Name or Submodule-Org in PR body"; exit 1
          fi
          echo "name=$NAME" >> $GITHUB_OUTPUT
          echo "org=$ORG"   >> $GITHUB_OUTPUT
          echo "repo=${ORG}/${NAME}-source" >> $GITHUB_OUTPUT

      - name: Comment on PR
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh pr comment ${{ github.event.pull_request.number }} \
            --body "✅ PR received for \`${{ steps.meta.outputs.name }}\`
          
          📁 This PR contains the folder content that will be converted to a submodule after merge.
          
          🔄 When this PR is merged, the workflow will:
          1. Create organization repository: \`${{ steps.meta.outputs.repo }\`
          2. Push folder content to the new repository
          3. Convert the folder to a submodule pointing to the new repository"

  # Job 2: When PR is merged - create repository and convert to submodule
  convert-to-submodule-on-merge:
    if: github.event.action == 'closed' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata from PR body
        id: meta
        run: |
          BODY=$(jq -r '.pull_request.body' "$GITHUB_EVENT_PATH")
          NAME=$(echo "$BODY" | sed -n 's/^Submodule-Name:[[:space:]]*//p' | head -1)
          ORG=$(echo "$BODY"  | sed -n 's/^Submodule-Org:[[:space:]]*//p'   | head -1)
          if [ -z "$NAME" ] || [ -z "$ORG" ]; then
            echo "Missing Submodule-Name or Submodule-Org in PR body"; exit 1
          fi
          echo "name=$NAME" >> $GITHUB_OUTPUT
          echo "org=$ORG"   >> $GITHUB_OUTPUT
          echo "repo=${ORG}/${NAME}-source" >> $GITHUB_OUTPUT

      - name: Configure git
        run: |
          git config user.name  "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"

      - name: Create working branch for submodule conversion
        id: branch
        run: |
          BRANCH_NAME="submodule-${NAME}-$(date +%Y%m%d%H%M%S)"
          git checkout -b "$BRANCH_NAME"
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "Created branch: $BRANCH_NAME"

      - name: Create Organization Repository
        env:
          GH_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN || github.token }}
        run: |
          set -x
          REPO="${{ steps.meta.outputs.repo }}"
          
          # Check if folder exists
          if [ ! -d "${{ steps.meta.outputs.name }}" ]; then
            echo "Error: Folder ${{ steps.meta.outputs.name }} does not exist"
            exit 1
          fi
          
          # Create repository if it doesn't exist
          if ! gh repo view "$REPO" >/dev/null 2>&1; then
            echo "Creating repository: $REPO"
            if ! gh repo create "$REPO" \
              --private \
              --description "Source repository for ${{ steps.meta.outputs.name }}" \
              --confirm; then
              echo "Failed to create repository: $REPO"
              echo "Debugging information:"
              echo "Current user: $(gh api user --jq '.login')"
              echo "Organization access: $(gh api org/dsrctest --jq '.login' || echo 'No access')"
              echo "Available repositories in org:"
              gh api org/dsrctest/repos --jq '.[].name' || echo "Cannot list org repos"
              exit 1
            fi
            echo "Successfully created repository: $REPO"
            
            # Initialize the repository with an initial commit
            echo "Initializing repository with initial commit..."
            TMPDIR=$(mktemp -d)
            cd "$TMPDIR"
            
            # Clone the empty repository
            git clone "https://github.com/$REPO.git" repo
            cd repo
            
            # Create initial README
            echo "# ${{ steps.meta.outputs.name }} Source Repository" > README.md
            echo "" >> README.md
            echo "This repository contains the source code for \`${{ steps.meta.outputs.name }}\`." >> README.md
            echo "" >> README.md
            echo "## About" >> README.md
            echo "This repository was automatically created by GitHub Actions workflow." >> README.md
            
            # Configure git
            git config user.name "${{ github.actor }}"
            git config user.email "${{ github.actor }}@users.noreply.github.com"
            
            # Create initial commit
            git add README.md
            git commit -m "Initial commit: Add README"
            git push -u origin main
            
            echo "Repository initialized with initial commit"
          else
            echo "Repository already exists: $REPO"
          fi
          
          # Verify repository exists before proceeding
          if ! gh repo view "$REPO" >/dev/null 2>&1; then
            echo "ERROR: Repository $REPO does not exist after creation attempt"
            exit 1
          fi

      - name: Push folder content to organization repo
        env:
          GH_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN || github.token }}
        run: |
          FOLDER="${{ steps.meta.outputs.name }}"
          REPO_URL="https://github.com/${{ steps.meta.outputs.repo }}.git"
          
          # Verify repository exists before attempting to push
          echo "Verifying repository exists: ${{ steps.meta.outputs.repo }}"
          if ! gh repo view "${{ steps.meta.outputs.repo }}" >/dev/null 2>&1; then
            echo "ERROR: Repository ${{ steps.meta.outputs.repo }} does not exist!"
            echo "Cannot push folder content to non-existent repository"
            echo "This indicates the repository creation step failed"
            exit 1
          fi
          echo "Repository exists, proceeding with push..."
          
          # Check if folder has any files
          if [ -z "$(find "$FOLDER" -type f | head -1)" ]; then
            echo "Warning: Folder $FOLDER is empty, creating placeholder file"
            echo "# $FOLDER Source Repository" > "$FOLDER/README.md"
            echo "This repository contains the source code for $FOLDER" >> "$FOLDER/README.md"
          fi
          
          # Use direct method to push folder content
          echo "Pushing folder content using direct method..."
          TMPDIR=$(mktemp -d)
          cp -r "$FOLDER" "$TMPDIR/repo"
          cd "$TMPDIR/repo"
          
          git init
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"
          
          git add .
          git commit -m "Add $FOLDER source content"
          git branch -M main
          
          git remote add origin "$REPO_URL"
          git push -u origin main

      - name: Convert folder to submodule
        run: |
          FOLDER="${{ steps.meta.outputs.name }}"
          REPO_URL="https://github.com/${{ steps.meta.outputs.repo }}.git"
          
          # Remove existing folder
          echo "Removing existing folder: $FOLDER"
          git rm -rf "$FOLDER" || true
          
          # Add repository as submodule
          echo "Adding repository as submodule..."
          git submodule add "$REPO_URL" "$FOLDER"
          
          # Commit the submodule addition
          git add .gitmodules "$FOLDER"
          git commit -m "Convert $FOLDER folder to submodule pointing to ${{ steps.meta.outputs.repo }}"

      - name: Push submodule branch
        run: |
          git push -u origin "${{ steps.branch.outputs.branch }}"

      - name: Merge submodule changes to main
        run: |
          # Switch to main branch
          git checkout main
          
          # Merge the submodule branch
          git merge "${{ steps.branch.outputs.branch }}" --no-ff -m "Merge: Convert ${{ steps.meta.outputs.name }} to submodule"
          
          # Push to main
          git push origin main
          
          # Clean up the branch
          git branch -d "${{ steps.branch.outputs.branch }}"
          git push origin --delete "${{ steps.branch.outputs.branch }}"